\chapter{Simulation}
\label{chap:Simulation}

To implement and research various FDIR systems on satellites an simulation of satellite dynamics and kinematics is developed. The focus of this thesis is on small satellites and more specifically cubesats. For the simulation of the ADCS of the satellite \cite{auret2012design, JansevanVuuren2015, Jordaan2016} were referenced during the development of the satellite simulation. The simulation was developed in Python to simulate the dynamics and kinematics during a satellite orbit. The faults for the subsystems are also developed within the simulation and will be discussed within this chapter.

\section{Attitude Determination and Control System}

For the mission of the specific satellite in this document the main operational goal of the Attitude Determination and Control System (ADCS) on this specific satellite mission is to control the payload to point towards the centre of the earth during eclipse and point the solar panels towards the sun during the sunlit phase. 

\subsection{Coordinate Frames}
The coordinate frames in aerospace is a fundamental part of the ADCS. To determine the orientation and position of an object, it should be relative to a fixed frame. Consequently, the Earth inertial coordinate (EIC) frame is the fixed frame from which every other frame is relative to.

A coordinate frame consists of three orthogonal vectors which is commonly referred to as x, y, and z. The axis of the coordinate frame is appropriately named as X-axis, Y-axis and Z-axis as seen in Figure... A vector ($\mathbf{r}$) within the current coordinate frame can thus be expressed as 
\begin{equation}
\mathbf{r} = x\mathbf{i} + y\mathbf{j} + z\mathbf{k}
\end{equation}
where the magnitude of $\mathbf{r}$ is denoted as $\norm{\mathbf{r}}$ and is equal to 
\begin{equation}
\norm{\mathbf{r}} = \sqrt{x^2 + y^2 + z^2}.
\end{equation}

The Earth-centered coordinate frames are dived into two, namely the EIC and earth fixed coordinate (EFC) frame. EFC is fixed to the earth and rotates with it. This frame is important with respect to where the satellite position is with regards to position's on earth, such as the ground station. It is also import for the modelling of the geomagnetic fields. 

% Insert a figure of the earth coordinate frames here

The EIC is defined as the Z-axis pointing towards the north pole, the X-axis pointing towards the Vernal Equinox, $\Upsilon$, and the Y-axis completing the orthogonal set. The EFC is a copy of the EIC, with the Z-axis being identical, however the EFC rotates with the earth. The EFC in relation to the EIC can be expressed by a single angle of rotation, which is the Greenwich Hour Angle (GHA), $\alpha_G$. With the knowledge of $t$ --- the elapsed time since $t_0$, $w_E$ --- the angular rate of the earth, and $\alpha_{G,0}$ --- the GHA at $t = t_0$, $\alpha_G$ can be calculated as 
\begin{equation}
\alpha_G = w_Et + \alpha_{G,0}
\end{equation}
To transform a vector from one coordinate frame to another, a transformation matrix, $\boldsymbol{A}$, is required. For example vector $\mathbf{r}_{EFC}$ can be transformed to $\mathbf{r}_{EIC}$ with 
\begin{equation}
\mathbf{r}_{EIC} = \boldsymbol{A}^{EIC}_{EFC}\mathbf{r}_{EFC}
\end{equation}
with $\boldsymbol{A}^{EIC}_{EFC}$ being the EFC-to-EIC transformation matrix. Due to the definition of both coordinate frames, $\boldsymbol{A}^{EIC}_{EFC}$ can be defined .

\begin{equation}
\boldsymbol{A}^{EIC}_{EFC} = 
\begin{bmatrix}
	cos(\alpha_G) & -sin(\alpha_G) & 0\\
	sin(\alpha_G) & cos(\alpha_G) & 0 \\
	0 & 0 & 1
\end{bmatrix}
\end{equation}

To determine the satellite position, satellite coordinate frames must be used. Three satellite-centred coordinate frames are used, namely the inertial-reference coordinate frame (the satellite does not rotate), the orbit-referenced coordinate (ORC) frame and the satellite body coordinate (SBC) frame. The IRC frame is only acknowledged, since it is the frame that is fixed (as it does not rotate around the centre of the satellite), however it changes position with the orbit of the satellite. This frame is not used to determine the position of the satellite and will not be referenced for the remainder of this document.

The ORC frame changes location as the satellite moves, however the Z-axis is always pointing towards the centre of the earth, with the Y-axis being the anti-normal and the X-axis completing the orthogonal set. To transform a vector from the EIC frame to the ORC frame the unit position vector, $\mathbf{r}_{sat}$ and the unit velocity vector, $\mathbf{v}_{sat}$ in EIC \cite{Chen_ground-target}.

\begin{equation}
\label{Eq: ORC to EIC}
\begin{aligned}
	\boldsymbol{A}^{ORC}_{EIC} &= 
	\begin{bmatrix}
		\mathbf{u} & \mathbf{v} & \mathbf{w}\\
	\end{bmatrix}^T \\
\text{where} \quad
\mathbf{w} &= -\frac{r_{sat}}{||r_{sat}||} \\
\mathbf{v} &= -\frac{r_{sat} \times v_{sat}}{||r_{sat} \times v_{sat}||} \\
\mathbf{u} &= \hat{v} \times \hat{w} \\
\end{aligned}
\end{equation}

The SBC frame is the frame fixed to the satellite and it is the relative rotation of the satellite in relation to the ORC. Thus for the mission of this satellite it is required that the SBC and ORC frames coincide. For the transformation of a vector from the ORC to SBC frame, the direct cosine matrix (DCM) also referred to as $\boldsymbol{A}$ or $\boldsymbol{A}^{SBC}_{ORC}$ is used. For the remainder of the document the DCM will be referred to as $\boldsymbol{A}^{SBC}_{ORC}$ to avoid any confusion. The calculation of this transformation matrix will be discussed in $\S$\ref{subsection_quaternions}.

% Insert a figure of the satellite coordinate frames here

\subsection{Attitude}
\label{subsection_quaternions}
To determine the attitude of an object, a model must be used to determine the rotation of an object in three dimensions. For this the visual and intuitive example of the Euler angles exist. Euler angles are the rotation of an object around three orthogonal axis, that change orientation with the rotation of the object. The three axes, denoted by X, Y and Z rotate with the object as depicted in Figure~\ref{fig:Pitch}.
\begin{figure}[!htb]
	\centering
	\def\svgwidth{12cm}
	\import{Figures/}{Pitch.pdf_tex}
	\label{fig:Pitch}
	\caption{Euler angles}
\end{figure}

The $\boldsymbol{A}^{SBC}_{ORC}$ can be used to calculate the attitude transformation from given Euler angle rotations. This is done by multiplying representing each individual Euler angle rotation as a transformation matrix. These matrices form the  $\boldsymbol{A}^{SBC}_{ORC}$ as given by 

\begin{equation}
	\begin{aligned}
		\mathbf{A} &= \mathbf{A}_{\psi} \mathbf{A}_{\phi} \mathbf{A}_{\theta} \\
			&= \begin{bmatrix}
			cos \psi & sin \psi & 0 \\
			-sin \psi & cos \psi & 0 \\
			0 & 0 & 1
			\end{bmatrix} \begin{bmatrix}
			1 & 0 & 0 \\
			0 & cos \phi & sin \phi \\
			0 & -sin \phi & cos \phi
			\end{bmatrix} \begin{bmatrix}
			cos \theta &  0 & -sin \theta \\
			0 & 1 & 0 \\
			sin \theta & 0 & cos \theta
			\end{bmatrix} \\
	\end{aligned}
\end{equation}

Euler angles however is not always a suitable method in determining the attitude of a satellite. This is because of singularities that can occur such as the gimbal-lock effect. Where two rotational axis, coincide to form a single rotational axis. Consequently, not all $3D$ rotations can then be described with the Euler angles, since effectively only two rotations can occur in stead of three \cite{diebel2006representing}. Therefore the method of describing 3D rotation with quaternions is more often used and more convenient. 

A quaternion, $\mathbf{q}$, has four components that are dependent on one another and constrained by 
\begin{equation} 
\label{Eq-quaternion dependency}
q_1^2 + q_2^2 + q_3^2 + q_4^2 = 1.
\end{equation}
The attitude quaternion is also related to the Euler angles in that if the Euler rotational axis from ORC to SBC is defined as a unit vector $\mathbf{e} = \begin{bmatrix} e_1  & e_2 & e_3 \end{bmatrix}^T$ and the angle of the Euler rotation is $\Phi$ then $\mathbf{q}$ can be expressed as
\begin{equation}
\mathbf{q} = \begin{bmatrix} e_1 sin(\frac{\Phi}{2}) \\ e_2 sin(\frac{\Phi}{2}) \\ e_3 sin(\frac{\Phi}{2}) \\ cos(\frac{\Phi}{2}) \end{bmatrix}
\end{equation}
It is difficult to visualize a quaternion, however the most simplistic method of understanding it is shown in Figure~\ref{fig:quaternion}. A quaternion is consequently a unit vector protruding from the centre point of an object as well as the angle of rotation of that object around that unit vector. As seen in Figure~\ref{fig:Pitch} the angle $\theta$ is the angle of rotation around the $z$-axis, for quaternions the angle of rotation is the same principle, however the axis around which the object is rotating, is the unit vector. Therefore, $q_4$ provides the angle of rotation while, $q_{1-3}$ represents the unit vector, however with the condition of Eq~\ref{Eq-quaternion dependency}.

\begin{figure}[!htb]
	\centering
	\def\svgwidth{12cm}
	\import{Figures/}{quaternion.pdf_tex}
	\label{fig:quaternion}
	\caption{Graphical quaternion representation}
\end{figure}

$\boldsymbol{A}^{SBC}_{ORC}$ can also be transformed as a function of $\mathbf{q}$ \cite{wertz2012spacecraft} through

\begin{equation}
	\mathbf{A}
		= \begin{bmatrix}
		q_1^2 - q_2^2 - q_3^2 + q_4^2 & 2(q_1q_2 + q_3q_4) & 2(q_1q_3 - q_2q_4) \\
		2(q_1q_2 - q_3q_4) & -q_1^2 + q_2^2 - q_3^2 + q_4^2 & 2(q_2q_3 + q_1q_4) \\
		2(q_1q_3 + q_2q_4) & 2(q_2q_3 - q_1q_4) & -q_1^2 - q_2^2 + q_3^2 + q_4^2 \\
		\end{bmatrix}.
\end{equation}
Since the quaternion is used for attitude determination it will also be used for the attitude control. Therefore, a error between the commanded quaternion, $\mathbf{q}_c$ and the current quaternion, $\mathbf{q}$, must be calculated. This is discussed in section~\ref{section: Quaternion Feedback Controller}.

\subsection{Satellite Kinematics and Dynamics}
The conservation of momentum dominates the dynamics of a satellite. This is dominated by the torques applied to the satellite, and are mainly control torques, $\mathbf{N_c}$, or disturbance torques, $\mathbf{N_d}$, as well as the moment of inertia of the satellite, $\mathbf{I}$, multiplied by the inertial-referenced angular acceleration of the satellite, $\boldsymbol{\dot{\omega}}_B^I$ . The control torques used in this design are only reaction wheel torques, $\mathbf{N}_w$ and magnetic torques, $\mathbf{N}_m$. The disturbance torques are discussed in detail in section~\ref{section: disturbance models}, therefore it can only be mentioned that the disturbance torques are the gravity gradient torque, $\mathbf{N}_{gg}$, the wheel imbalance torque, $\mathbf{N}_{rw}$, the gyroscopic coupling torque, $\mathbf{N}_{gyro}$, and the aerodynamic disturbance torque, $\mathbf{N}_{aero}$. The Euler dynamic equation can therefore be given as

\begin{equation}
\begin{aligned}
	\mathbf{I}\boldsymbol{\dot{\omega}}_B^I &= \mathbf{N_c} + \mathbf{N_d}, \\
	\text{where} \quad \mathbf{N_d} &\approx \mathbf{N}_{aero} - \mathbf{N}_{gyro} + \mathbf{N}_{gg} + \mathbf{N}_{rw}, \\
	\text{and} \quad \mathbf{N_c} &= \mathbf{N}_{m} - \mathbf{N}_{w}.
\end{aligned}
\end{equation}

This is the overarching equation that will be used to determine the control torque as well as the model update of the extended Kalman Filter (EKF). The integration method used in the simulation is the $4^{th}$ order Rungka-Kutta method to solve the differential equations. This is demonstrated with algorithm~\ref{alg: rungka-kutta}.

\begin{algorithm}[!htb]
	\caption[Multi-variate Guassian Distribution]{Multi-variate Guassian Distribution Algorithm}
	\label{alg: rungka-kutta}
	\begin{algorithmic}[1]
		\State Definitions: Ts - Timestamp; 
		\State $h = Ts/N$ 
		\For{$n\leftarrow 1$ to $N$}
		\State	$k_1 = hf(x_n, y_n)$
		\State	$k_2 = hf(x_n + \frac{h}{2}, y_n + \frac{k_1}{2})$
		\State	$k_3 = hf(x_n + \frac{h}{2}, y_n + \frac{k_2}{2})$
		\State	$k_4 = hf(x_n + h, y_n + k_3)$
		\State	$y_{n+1}=y_n + \frac{k_1}{6} + \frac{k_2}{3} + \frac{k_3}{3} + \frac{k_4}{6}$
		\EndFor

	\end{algorithmic}
\end{algorithm}

where $h$ is the step size, which is set to $T_s/10$, where the time step, $T_s$, is equal to one second. With this procedure the dynamics and kinematics of the satellite can be simulated after each time step.


\section{Environment}
To ensure an accurate simulation environment certain phenomena must be determined to ensure that the satellite's eclipse

\subsection{Orbit Propagation}
The satellite position, $\mathbf{r}_{sat}$ and velocity $\mathbf{v}_{sat}$ at a given time step is required to determine the multiple different variables required for the simulation environment. Therefore the refined version of the simplified general perturbations (SGP) model, namely SGP4, is used as orbit propagator of the satellite after each time step \cite{vallado2006revisiting}. 

To determine $\mathbf{r}_{sat_k}$ and $\mathbf{v}_{sat_k}$ at time step, $k$, the two-line element, (TLE), set of the satellite is required. The TLE set is an encoding of the specified satellite orbit, which requires parameters such as the semimajor axis, $a$, right ascension of the ascending node (RAAN), $\Omega$, argument of perigee (AP), $\omega$, inclination, $i$, eccentricity, $e$, and the time at the beginning of the orbit as a Julian date, $J_t$. With these parameters and the elapse time since $J_t$, both $\mathbf{r}_{sat_k}$ and $\mathbf{v}_{sat_k}$ can be determined from the World Geodetic System 72 constants that is implemented by the SGP4 model.

\begin{figure}[!htb]
	\centering
	\def\svgwidth{12cm}
	\import{Figures/}{EarthOrbit.pdf_tex}
	\label{fig:EarthOrbit}
	\caption{SGP4 orbit propagation}
\end{figure}


The SGP4 outputs the $\mathbf{r}_{sat_k}$ and $\mathbf{v}_{sat_k}$ in the EIC reference frame. Therefore, $\boldsymbol{A}^{ORC}_{EIC}$ can now be calculated according to Eq-\ref{Eq: ORC to EIC}.

\subsection{Sun}
The calculations for the sun position and also the placement of the coarse and fine sun sensor.

\begin{equation}
	\begin{aligned}
		\mathbf{r}_{sun} &= r_{\oplus} \begin{bmatrix}
		cos(\lambda_e) \\ cos(\epsilon)sin(\lambda_e) \\ sin(\epsilon)sin(\lambda_e) \\
		\end{bmatrix}, \\
		\text{where} \quad r_{\oplus} &= \num{1.000140612} - \num{0.016708617} \, cos(M_{\oplus}) - \num{0.00139589} \, cos(2M_{\oplus}), \\
		M_{\oplus} &= \num{357.527723300}^o + \num{35999.050340} \, T_{JC}, \\
		\lambda_e &= \lambda_{M_{\oplus}} + \num{1.914666471} \, sin(M_{\oplus}) + \num{0.019994643} \, sin(2M_{\oplus}), \\
		\lambda_{M_{\oplus}} &= \num{280.460618400}^o + \num{36000.770053610} \, T_{JC}, \\
		\epsilon &= \num{23.439291}^o - \num{0.013004200} \, T_{JC} \\
		\text{and} \quad T_{JC} &= \frac{J_t - \num{2451545}}{\num{36525}}.
	\end{aligned}
\end{equation}



\begin{equation}
S_{EIC} = \mathbf{r}_{sun} - \mathbf{r}_{sat}
\end{equation}

\begin{figure}[!htb]
	\centering
	\def\svgwidth{12cm}
	\import{Figures/}{SunToEarthToSat.pdf_tex}
	\label{fig:SunToEarthToSat}
	\caption{Geometry for satellite eclipse}
\end{figure}


\subsection{Geomagnetic field}

\begin{equation}
\label{Eq-Geomagnetic_field}
V(r_s,\theta, \lambda) = R_E \sum_{n=1}^{k}\left(\frac{R_E}{r_s}^{n+1}\right)\sum_{m=0}^{n}\left(g_n^mcos(m\lambda) + h_n^msin(m\lambda)\right)P_n^m(\theta)
\end{equation}

\section{Sensor models}

Sun sensor, nadir, magnetometer.

\begin{equation}
\mathbf{v}_b = \mathbf{A}_{ORC}^{EIC} \mathbf{v}_{ORC} + \mathbf{m}_v
\end{equation}

\subsection{Sun Sensor}

\textbf{TODO: Show position of sun sensor...}

\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Sun_large.pgf}
	
	\caption{Sun vector in SBC}
	\label{fig:SunSensorPlot}
\end{figure}

\subsection{Nadir Sensor}

\textbf{TODO: Show position of nadir sensor...}
\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Earth_large.pgf}
	
	\caption{Earth vector in SBC}
	\label{fig:EarthSensorPlot}
\end{figure}

\subsection{Magnetometer}

\textbf{TODO: Show position of magnetometer...}
\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Magnetometer_large.pgf}
	
	\caption{Magnetometer in SBC}
	\label{fig:MagnetometerPlot}
\end{figure}

\section{Disturbance models}
The first disturbance torque is that of the gyroscopic coupling which can be calculated with

\begin{equation}
\mathbf{N}_{gyro} = \boldsymbol{\dot{\omega}}_B^I \times (\mathbf{I}\boldsymbol{\dot{\omega}}_B^I + \mathbf{h}_w),
\end{equation}
where $h_w$ is the angular momentum of the reaction wheels. The other disturbance torques are discussed in more detail below.

\label{section: disturbance models}
\subsection{Gravity Gradient}

\begin{equation}
\boldsymbol{N}_{gg} = 3 \, \omega_o^2 (\mathbf{z}_o^B \times \mathbf{Iz}_o^B)
\end{equation}

\begin{equation}
\mathbf{z}_o^B = \mathbf{A} \begin{bmatrix} 0 & 0 & 1 \end{bmatrix}^T
\end{equation}

\begin{equation}
\begin{aligned}
\mathbf{N}_{gg} &= \begin{bmatrix}
					k_{gx}A_{23}A_{33} \\
					k_{gy}A_{13}A_{33} \\
					k_{gz}A_{13}A_{23} \\
					 \end{bmatrix} \\
\text{where} \quad 	k_{gx} &= 3 \, \omega_o^2(\mathbf{I}_{zz} - \mathbf{I}_{yy}), \\
					k_{gy} &= 3 \, \omega_o^2(\mathbf{I}_{xx} - \mathbf{I}_{zz}), \\
\text{and} \quad  	k_{gz} &= 3 \, \omega_o^2(\mathbf{I}_{yy} - \mathbf{I}_{xx}),
\end{aligned}
\end{equation}

\subsection{Aerodynamic Disturbance}
\cite{Steyn2014}

\begin{equation}
\begin{aligned}
\mathbf{N}_{aero} = \sum_{i=1}^{n}\Big(& \rho \norm{\mathbf{v}_A^B}^2 A_i H \{cos(\alpha_i)\} \, cos(\alpha_i) \big(\sigma_t (\mathbf{r}_{pi} \times \mathbf{\bar{v}}_A^B) \\
					 & + \big[ \sigma_nS + (2 - \sigma_n - \sigma_t) cos(\alpha_i)\big] (\mathbf{r}_pi \times \mathbf{\bar{n}}_i) \big) \vphantom{\norm{\mathbf{v}_A^B}^2}\Big)
\end{aligned}
\end{equation}

\begin{equation}
\rho = \rho_o e^{-\frac{h-h_o}{H}}
\end{equation}

\begin{equation}
\mathbf{v}_A^{EIC} = \begin{bmatrix} 0 \\ 0 \\ \omega_E \end{bmatrix} \times \mathbf{r}_{sat} - \mathbf{v}_{sat}
\end{equation}

\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Aerodynamic Torques.pgf}
	
	\caption{Aerodynamic Torques in SBC}
	\label{fig:AerodynamicTorques}
\end{figure}

\subsection{Wheel Imbalance}

\begin{equation}
\mathbf{F}_{xs} = U_s\omega^2 \begin{bmatrix} sin(\omega t + \phi_s) \\ cos(\omega t + \phi_s) \\ 0 \end{bmatrix}
\end{equation}

\begin{equation}
\mathbf{N}_{xs} = w_z + F_{xs}
\end{equation}

\begin{equation}
F_{xd} = mr\omega^2
\end{equation}

\begin{equation}
\mathbf{N}_{xs} = U_d\omega^2 \begin{bmatrix} sin(\omega t + \phi_d) \\ cos(\omega t + \phi_d) \\ 0 \end{bmatrix},
\end{equation}
where $U_d = mrd$ is the dynamic imbalance. $U_s = 2.08e^{-7}$, $U_d = 2.08e^{-9}$

\textbf{TODO: Show drawing of static and dynamic wheel imbalance...}

\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Wheel disturbance Torques.pgf}
	
	\caption{Wheel disturbance torques in SBC}
	\label{fig:Wheel disturbance Torques}
\end{figure}

\section{Attitude Determination}
In this section discuss the Kalman filter.

\subsection{Extended Kalman Filter}
The implementation of the estimated kalman filter \emph{EKF} is for estimation of the current satellite attitude with sensor fusion of the magnetometer, star tracker, sun sensor and nadir sensor to accurately estimate the attitude and rotation rate of the satellite. The EKF will be used due to the non-linear nature of the system. The EKF consists of two fundamental parts, the model update and the measurement update. The general form for a system model can be expressed as

\begin{equation}
	\dot{x_t} = \mathbf{f}(x_t) + s_t
\end{equation}

where $\mathbf{f}(x_t)$ is a non-linear function of $x_t$. The state vector, $x$, for the full 7-state EKF consists of the quaternion vector, $q$ and the inertial-referenced angular velocity, $\omega_B^I$.

\begin{equation}
	x = [q, \omega_B^I]^T
\end{equation}

The estimated state vector $x$ will be denoted as $\hat{x}$ and the estimated vector before and after the measurement update will be indicated with a superscript $'-'$ and $'+'$ respectively. To calculate the model update the dynamics and kinematics of the system model is used to calculate both $\omega_B^I$ and $q$. The integration method used in the simulation is the 4th order Rungka-Kutta method to solve the differential equations. The integration method is shown in \ref{alg: Rungka-Kutta} where $(\hat{\omega}_B^I)_k^-$ is calculated for the first step of the model update.

\begin{algorithm}[!htb]
	\caption[Rungka-Kutta]{Rungka-Kutta 4th order Algorithm at time $k$}
	\label{alg: Rungka-Kutta}
	\begin{algorithmic}[1]
		\State Satellite Body Inertia $\mathbf{J} = \begin{bmatrix}
			0.4 & 0 & 0\\
			0 & 0.45 & 0 \\
			0 & 0 & 0.3
		\end{bmatrix}$
		\State Timestep ($T_s$) $= 1s$
		\State Number of iterations ($I$) $= 10$
		\State Step size $h = \frac{T_s}{h}$
		\State Disturbance torques $N_d = N_{gg} - N_{gyro} $ % + N_{aero} + N_{rw}$
		\State Control torques $N_c = N_m - N_w$
		\State $\mathbf{N} = N_c + N_d$
		\For{\texttt{$n \in I$}}
		\State \texttt{$k_1 = h(\mathbf{J^{-1}}\mathbf{N})$}
		\State \texttt{$k_2 = h(\mathbf{J^{-1}}\mathbf{N} + \frac{k1}{2})$}
		\State \texttt{$k_3 = h(\mathbf{J^{-1}}\mathbf{N} + \frac{k_2}{2})$}
		\State \texttt{$k_4 = h(\mathbf{J^{-1}}\mathbf{N} + k_3)$}
		\State \texttt{$\omega_{n+1}=\omega_n + \frac{k_1}{6} + \frac{k_2}{3} + \frac{k_3}{3} + \frac{k_4}{6}$}
		\EndFor
		\State $(\hat{\omega}_B^I)_k^- = \omega_{n+1}$
		\State \textbf{return} $(\hat{\omega}_B^I)_k^-$
	\end{algorithmic}
\end{algorithm}
where $N_{gg}$, gravity gradient disturbance torque, $N_{aero}$, aerodynamic disturbance torque, $N_{rw}$, reaction wheel disturbance torque, $N_{gyro}$, gyroscopic torque, $N_m$, magnetic control torque and $N_w$, reaction wheel control torque, are modelled according to \cite{JansevanVuuren2015}. 

%\begin{equation}
%	f(x,y) = \mathbf{J^{-1}}\big((N_m)_{k-1} - (N_w)_{k-1} - (N_{gg})_{k-1} - (N_{gyro})_{k-1} \big)
%\end{equation}
The calculation for the $\hat{q}_k^-$ is done with Eq~\ref{eq:q-propagation} \cite{JansevanVuuren2015}

\begin{equation}
	\begin{aligned}
		\hat{q}_k^- &= \left[cos(k_q)\mathbf{I}_{4x4} + \frac{1}{\lVert (\hat{\omega}_B^O)_k^- \rVert} sin(k_q) \mathbf{\Omega}_k^- \right] \hat{q}_{k-1}^+ \\ \\
		\text{where } k_q &= \frac{Ts}{2} \lVert (\hat{\omega}_B^O)_k^- \rVert \\ \\
		(\hat{\omega}_B^O)_k^- &= (\hat{\omega}_B^I)_k^- - \hat{\mathbf{A}} \begin{bmatrix} 0 & -(\omega_k) & 0\end{bmatrix}^T \\
		&= \begin{bmatrix} \hat{\omega}_{ox} & \hat{\omega}_{oy}  & \hat{\omega}_{oz} \end{bmatrix}^T \\ \\
		\lVert (\hat{\omega}_B^O)_k^- \rVert &= \sqrt{\hat{\omega}_{ox}^2 + \hat{\omega}_{oy}^2 + \hat{\omega}_{oz}^2} \\ \\
		\text{and } \mathbf{\Omega}_k^- &= \begin{bmatrix} 
			0 & \hat{\omega}_{oz} & -\hat{\omega}_{oy} & \hat{\omega}_{ox} \\
			-\hat{\omega}_{oz} & 0 & \hat{\omega}_{ox} & \hat{\omega}_{oy}			\\
			\hat{\omega}_{oy} & -\hat{\omega}_{ox} & 0 & \hat{\omega}_{oz}			\\
			-\hat{\omega}_{ox} & -\hat{\omega}_{oy} & -\hat{\omega}_{oz} & 0			\\
		\end{bmatrix}
	\end{aligned}
	\label{eq:q-propagation}
\end{equation}

The estimated state vector, $\hat{x}_k^-$ can now be expressed as 

\begin{equation}
	\hat{x}_k^- = \begin{bmatrix} (\hat{\omega}_B^I)_k^- & \hat{q}_k^-\end{bmatrix}
\end{equation}

$Q_k$ is the covariance matrix representing the discrete system noise and is assumed to be zero-mean and Guassian. $\Phi_k$ is the discrete system perturbation model. $H_k$ is the discrete measurement perturbation Jacobian Matrix. $\mathbf{R}_k$ is the measurement noise covariance matrix. The state covariance matrix $P_k$ can be propagated with Eq~\ref{eq:P_k}.

\begin{equation}
	\mathbf{P}_k^- = \Phi_k \mathbf{P}_{k-1}^+ \Phi_k ^T
	\label{eq:P_k}
\end{equation}
The $\mathbf{e}_k$ calculated with Eq~\ref{eq:errorVector}

\begin{equation}
	\mathbf{e}_k = v_{meas,k} - \hat{\mathbf{A}}_k^- v_{model,k}
	\label{eq:errorVector}
\end{equation}

where $v_{meas,k}$ is the measured vector in $\mathbf{SBC}$ and $v_{model,k}$ is the modelled $\mathbf{ORC}$ vector. The gain matrix $\mathbf{K}_k$ is used to determine the the influence of $\mathbf{e}_k$ on updated state vector, $\hat{x}_k^+$. $\mathbf{K}_k$ can be calculated as 

\begin{equation}
	\mathbf{K}_k = \mathbf{P}_k^- (\mathbf{H}_k^-)^T \left[\mathbf{H}_k^- \mathbf{P}_k^- (\mathbf{H}_k^-)^T + \mathbf{R}_k \right]^{-1}
\end{equation}
after which the updated state vector can be calculated with Eq~\ref{eq:UpdatedStateVector}
\begin{equation}
	\hat{x}_k^+ = \hat{x}_k^- + \mathbf{K}_k \mathbf{e}_k
	\label{eq:UpdatedStateVector}
\end{equation}

The state covariance matrix can then be updated as

\begin{equation}
	\mathbf{P}_k^+ = \left[\mathbf{I}_{7 \times 7} - \mathbf{K}_k \mathbf{H}_k^+ \right]\mathbf{P}_k \left[\mathbf{I}_{7 \times 7} - \mathbf{K}_k \mathbf{H}_k^+ \right] + \mathbf{K}_k \mathbf{R}_k \mathbf{K}_k^T
	\label{eq:Updated_P_k}
\end{equation}

During the measurement update of $\hat{x}_k^-$ with the error of $v_{meas,k}$ and $v_{model,k}$, the $\hat{x}_k^+$ is largely affected by anomalous behaviour in the sensor measurements. The sensitivity of the Kalman filter to this behaviour as well as related work will be discussed in section~\ref{subsection:SensitivityOfKalmanFilter}.

\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Estimation Metric.pgf}
	
	\caption{Estimation Metric}
	\label{fig:Estimation Metric}
\end{figure}


\section{Attitude Control}
To ensure that the satellite is able to satisfy the mission requirements, control of the satellite attitude is required. Therefore, the satellite's payload must be in the direction of the earth during eclipse and the solar panels should be pointing in the direction of the sun during the sunlit phase. For this control a quaternion feedback controller of the reaction wheels is implemented and a momentum dumping with the magnetorquers is implemented to ensure that the wheel disturbance remains within reasonable boundaries.

\subsection{Quaternion Feedback Controller}
\label{section: Quaternion Feedback Controller}
To ensure that the satellite is in the desired orientation the reaction wheels are used. To ensure stable control in all three axis \cite{wie1989quarternion} the quaternion feedback reaction wheel controller is implemented. The controller is designed from the estimated orientation and angular velocity, while ignoring disturbance torques. Eq~\ref{Eq-EulerDynamic} without the disturbance torques becomes
\begin{equation}
\mathbf{J}\dot{\boldsymbol{\omega}_B^I} = -\mathbf{N}_w - \mathbf{N}_{gyro}
\end{equation}
To calculate the required torque, $\mathbf{N}_{w,req}$, the definition according to \cite{steyn2008attitude} for all cases at time step, $k$, is given as
\begin{equation}
	\mathbf{N}_w(k) = K_{PI}\mathbf{Jq}_{err}(k) + K_{DI}\mathbf{I}\hat{\boldsymbol{\omega}}_B^O - \hat{\boldsymbol{\omega}}_B^I(k) \times [\mathbf{J}\hat{\boldsymbol{\omega}}_B^I(k) + \mathbf{h}_{w}(k)]
\end{equation}
where $\mathbf{h}_{w}(k)$ is the measured angular momentum of the wheels, the control gains are defined as
\begin{equation}
	\begin{aligned}
		K_{PI} &= 2 \omega_n^2\\
		K_{DI} &= 2 \zeta \omega_n \\
	\end{aligned}
	\label{eq:controlGain}
\end{equation}
the quaternion error is calculated with the quaternion difference operator, $\Theta$, as
\begin{equation}
	\begin{aligned}
		\mathbf{q}_{err}(k) &= \mathbf{q_c}(k) \Theta \hat{\mathbf{q}}(k) \\
		\begin{bmatrix} 
			q_{1e} \\
			q_{2e} \\
			q_{3e} \\
			q_{4e}
		\end{bmatrix} &= \begin{bmatrix} 
			q_{4c} & q_{3c} & -q_{4c} & -q_{4c} \\
			-q_{3c} & q_{4c} & q_{1c} & -q_{2c} \\
			q_{2c} & - q_{1c} & q_{4c} & -q_{3c} \\
			q_{1c} & q_{2c} & q_{3c} & q_{4c}
		\end{bmatrix}
		\begin{bmatrix} 
			\hat{q}_1 \\
			\hat{q}_2 \\
			\hat{q}_3 \\
			\hat{q}_4
		\end{bmatrix}
	\end{aligned}
	\label{eq:quaternionError}
\end{equation}
where $\hat{\mathbf{q}}$ is the current estimated quaternion and $q_{c}$ is the command quaternion which is $\begin{Bmatrix}
	0 & 0 & 0& 1
\end{Bmatrix}^T$ during eclipse and during the sun following phase, the attitude command according to \cite{chen2000ground} can be calculated as 
\begin{equation}
	\mathbf{q}_c = \begin{bmatrix}
		\mathbf{u}_c sin(\frac{\delta}{2}) \\
		cos(\frac{\delta}{2})
	\end{bmatrix},
\end{equation}
where 
\begin{equation}
	\mathbf{u}_c = \frac{\mathbf{u}_{sp}^{SBC} \times \mathbf{s}_o}{\norm{\mathbf{u}_{sp}^{SBC} \times \mathbf{s}_o}}.
\end{equation}
$\mathbf{s}_o$ is the measured unit sun vector in ORC, and the main solar panel's position is denoted as a unit vector, $\mathbf{u}_{sp}^{SBC}$. The angle between $\mathbf{u}_{sp}^{SBC}$ and $\mathbf{s}_o$, $\delta$, can be calculated with the vector dot-product. This can then be used as the reference for the control. The reference $\boldsymbol{\omega}_b^I$ is always $[0, 0, 0]$. 

\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Pointing Metric.pgf}
	
	\caption{Pointing Metric}
	\label{fig:Pointing Metric}
\end{figure}

\subsection{Momentum Dumping}
Momentum dumping is crucial to ensure that the wheel disturbance does not cause the system to become unstable. Momentum dumping is implemented during eclipse after the satellite is in a stable nadir-pointing attitude. The momentum dumping is implemented with magnetic torquers based on a Cross-Product controller. 

The magnetic dipole moment $\mathbf{M}$ is calculated as 
\begin{equation}
\mathbf{M} = \frac{\mathbf{e} \times \mathbf{B}}{\norm{\mathbf{B}_b}^2}
\end{equation}
where $\mathbf{B}_b$ is the geomagnetic field and the error vector, $\mathbf{e}$ can be calculated as
\begin{equation}
\mathbf{e} = -K_w(\mathbf{h_w} - \mathbf{h_w,ref})
\end{equation}
where $K_w$ is a positive gain. This momentum dumping is implemented $200s$ after sun-following phase is implemented, to ensure stable control and reduce the momentum in the reaction wheels. The magnetorquers torques are shown in Figure~\ref{fig:Magnetic Control Torques} and it is evident that when the satellite control changes from eclipse to sunlit and from sunlit to eclipse the magnetorquers torques increase to compensate for the increase in reaction wheel torques and to minimise the dynamic reaction wheel disturbance.

\begin{figure}[!htb]
	\centering
	\def\pgfwidth{12cm}
	\import{Figures/TexFigures/Predictor-None/Isolator-None/Recovery-None/EARTH_SUN-ORC-General CubeSat Model/None/}{Magnetic Control Torques.pgf}
	
	\caption{Magnetic Control Torques}
	\label{fig:Magnetic Control Torques}
\end{figure}


%\section{Constellations}
%Explain the design of the satellite constellations and the algorithms to run communicate between satellites.
%
%\begin{algorithm}
%	
%	\SetKwInOut{Input}{Input}
%	\SetKwInOut{Output}{Output}
%	
%	\SetKwData{Left}{left}
%	\SetKwData{This}{this}
%	\SetKwData{Up}{up}
%	\SetKwFunction{Union}{Union}
%	\SetKwFunction{FindCompress}{FindCompress}
%	
%	\Indm
%	\Input{Description of the input to the algorithm.}
%	\Output{Description of the output from the algorithm.}
%	\Indp
%	
%	\BlankLine
%	
%	\emph{Initialize hyperparameters}\;
%	Get initial data from satellite\\
%	Update positions of each satellite\\
%	\For{$i\leftarrow 1$ \KwTo $N$}{
%		Determine $k$-nearest satellites to $satellite_i$ from the positions\\
%		Select data from nearest satellites\\
%		Send nearest satellites predictions and data to $satellite_i$\\
%		Retrieve data from $satellite_i$ and fault predictions of $k$-nearest satellites\\
%	}
%	Update position of $satellite_i$\\
%	Update data of $satellite_i$
%	
%	\caption[Do not end short caption with full-stop]{Algorithm example}
%	\label{alg}
%	
%\end{algorithm}


%\section{Typical Faults}
%For the simulation of the satellite and the induced faults to train and test various anomaly detection methodologies a database of typical faults is required. \cite{tafazoli2009study} made a study of the percentage of failure per subsystem. 
%
%\subsection{Probability of Fault Occurence}
%The occurrence of a fault depends on the reliability of that equipment. \cite{Guo2014} studied the reliability of small satellites and calculated the parameters for the Weibull distribution based on real data. To model the probability of a fault to occur the probability density function is used \cite{Jones2017}.
%
%This probability however is small and for the training of the system the data is too sparse for the computational abilities of any regular PC. Thus the probability of a failure during training is fixed to $1/1000000$ to produce the data required for the anomaly detection with a million test samples.
%
%\subsection{Set of faults}
%A set of typical faults for the ADCS is shown in Table~\ref{ADCS fault table}. 
%
%\newpage
%\begin{sidewaystable}[]
%	\label{ADCS fault table}
%	\begin{tabular}{|l|c|l|l|l|l|}
%		\hline
%		\multicolumn{6}{|c|}{\textbf{Internal Faults}} \\ \hline
%		\textbf{Fault classes} &
%		\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}Failure rate \\ per hour\end{tabular}}} &
%		\textbf{Fault causes} &
%		\textbf{References} &
%		\textbf{Possible effect} &
%		\textbf{Possible permutations} \\ \hline
%		\multirow{4}{*}{Reaction wheels} &
%		\multicolumn{1}{l|}{\multirow{4}{*}{2.5E-7 \cite{Spilhaus1987}}} &
%		\begin{tabular}[c]{@{}l@{}}Reaction wheel electronics \\ fail\end{tabular} &
%		\cite{allen2012satellite} \cite{Jacklin2019} &
%		\begin{tabular}[c]{@{}l@{}}Does not respond \\ to control inputs\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Momentum remains the same \\ or decreases slightly due to \\ friction\end{tabular} \\ \cline{3-6} 
%		&
%		\multicolumn{1}{l|}{} &
%		Overheated reaction wheel &
%		\cite{Wintoft} &
%		Decrease in speed &
%		1\% of initial speed per second \\ \cline{3-6} 
%		&
%		\multicolumn{1}{l|}{} &
%		\begin{tabular}[c]{@{}l@{}}Catastrophic failure (cause \\ unknown)\end{tabular} &
%		\cite{Choi2011} &
%		Stops rotating &
%		0 \\ \cline{3-6} 
%		&
%		\multicolumn{1}{l|}{} &
%		\begin{tabular}[c]{@{}l@{}}Increase in rotation speed \\ (Unknown cause)\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Gerhard Janse \\ van Vuuren\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Wheel speed \\ increases\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Between 90-100\% of maximum \\ wheel speed\end{tabular} \\ \hline
%		Magnetorquers &
%		\multicolumn{1}{l|}{ADCS fault table8.15E-9 \cite{Spilhaus1987}} &
%		Polarities are inverted &
%		\cite{Crowell2011} &
%		Incorrect rotation &
%		\\ \hline
%		\multirow{2}{*}{Magnetometers} &
%		\multicolumn{1}{l|}{\multirow{2}{*}{8.15E-9 \cite{Spilhaus1987}}} &
%		Unknown &
%		\begin{tabular}[c]{@{}l@{}}Gerhard Janse \\ van Vuuren\end{tabular} &
%		Stops reacting &
%		\begin{tabular}[c]{@{}l@{}}Provides no feedback or the \\ output remains constant\end{tabular} \\ \cline{3-6} 
%		&
%		\multicolumn{1}{l|}{} &
%		\begin{tabular}[c]{@{}l@{}}Magnetometers and magne-\\ torquers interfered with \\ each other\end{tabular} &
%		\cite{Jacklin2019} &
%		\begin{tabular}[c]{@{}l@{}}Noise on magneto-\\ meters and noise \\ on control of mag-\\ netorquers\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Between x3 and x5 times the \\ normal noise magnitude \\ Guassian distribution\end{tabular} \\ \hline
%		Earth Sensor &
%		- &
%		Unknown &
%		\cite{Robertson2019} &
%		\begin{tabular}[c]{@{}l@{}}Noisy Earth Sensor \\ effected pointing \\ accuracy\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Between x5 and x10 times the \\ normal sensor noise based on \\ Guassian distribution\end{tabular} \\ \hline
%		\multirow{2}{*}{Sun sensor} &
%		\multirow{2}{*}{-} &
%		\begin{tabular}[c]{@{}l@{}}Cross-wired during instal-\\ lation\end{tabular} &
%		\cite{Crowell2011} &
%		\begin{tabular}[c]{@{}l@{}}Erroneous \\ measurements\end{tabular} &
%		Uniform random values \\ \cline{3-6} 
%		&
%		&
%		Unknown &
%		\cite{Jacklin2019} &
%		Sun sensor fails &
%		output is 0 \\ \hline
%		Star tracker &
%		- &
%		\begin{tabular}[c]{@{}l@{}}Shutter on star tracker is \\ closed\end{tabular} &
%		\cite{Crowell2011} &
%		Star tracker fails &
%		output is 0 \\ \hline
%		Overall control &
%		- &
%		\begin{tabular}[c]{@{}l@{}}Incorrect control law or \\ variation \\ thereof\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Gerhard Janse \\ van Vuuren\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Angular velocity \\ suddenly increases \\ or decreases or \\ oscillation results\end{tabular} &
%		\begin{tabular}[c]{@{}l@{}}Increase to 75 - 100\% \\ Decrease to 0 - 25\%\\ Oscillates\end{tabular} \\ \hline
%		\multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}Common data \\ transmission errors\end{tabular}} &
%		\multirow{3}{*}{-} &
%		Sign flip &
%		\cite{Crowell2011} &
%		Processor-based &
%		\begin{tabular}[c]{@{}l@{}}Processor outputs and/or \\ inputs experience a sign flip\end{tabular} \\ \cline{3-6} 
%		&
%		&
%		Bit flip &
%		N/A &
%		&
%		\begin{tabular}[c]{@{}l@{}}Processor outputs and/or \\ inputs experience a bit flip flip\end{tabular} \\ \cline{3-6} 
%		&
%		&
%		Insertion of zeros &
%		\cite{Jacklin2019} &
%		&
%		\begin{tabular}[c]{@{}l@{}}Processor outputs and/or inputs \\ experience an insertion of a zero\end{tabular} \\ \hline
%		\begin{tabular}[c]{@{}l@{}}Possible sensors \\ errors\end{tabular} &
%		- &
%		Unknown &
%		N/A &
%		High sensor noise &
%		\begin{tabular}[c]{@{}l@{}}Between x5 and x10 times the \\ normal sensor noise based on \\ Guassian distribution\end{tabular} \\ \hline
%	\end{tabular}
%\end{sidewaystable}
%
%\newpage